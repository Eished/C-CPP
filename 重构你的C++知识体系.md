〖课程介绍〗:
        从学习角度看，C++是一门“见效慢”的语言；学习曲线陡峭，语言本身复杂。但，如果你想了解很多编程语言的思想源泉，想要一窥大型企业级开发工程的思路，想开发别人做不了的高性能程序，那C++就是你的不二之选。如果你想成为一名资深开发人员，想一窥底层细节，那么，这门课就是为你设计的。课程将从C++的发展史讲起，从知识与思想层面 从0带你构建C++知识框架，并会分享讲师亲历的大型项目实践思路，为你打下坚实的基础

〖课程目录〗:

[toc]



# 第1章 C++概括

了解C++的历史概况，C++语言的特点及C++语言作用，认识哪些场合下C++是无可替代的；

##  1-1 2020重C++ 课程导学

大型桌面应用

- Adobe Photoshop
- Google Chrome
- Microsoft offce

大型网站后台

- 搜索引擎

大型游戏后台

- 王者荣耀

大型游戏引擎

- Unreal、Unity

编译器/解释器

- LLVM/ClangGCC

- Java虛拟机

- javaScript引擎

视觉和只能引擎

- OpenCV
- TensorFlow

##  1-2 CPP的历史

1. C，C++发展历史
   - C++编程语言的历史可追溯到1979，Bjarne Stroustrup；创立了带类的G。顾名思义，这是C语言的超集：1983，语言的名字真正变成了C++
   - C++在最开始可以称作C语言的增强版，但在后来，C++又引入了很多新的功能，逐步增强了C++的可用性1998年伴随着STL标准库的诞生，一堆新的功能和特性的产生，C++标准委员会发布了第个国际标准C+++SO/EC1488：称为C++98；
2. C，C++发展历史（续）
   - 在2011年中期，C++标准（称为C++11）完成了新的标准Boost库项目对新标准产生了相当大的影响，一些新模块直接从相应的 Boost库中派生出来。
   - C++11—之后，C+以每三年一版的频度发布着新的语言标准，每一版都在基本保留向后兼容性的同时，提供着改进和新功能

##  1-3 CPP的特点

1. 为什么C++比C更好
   - 在中进行功能扩展会比较困难比如此例子里没有一个合适的位置来存储状态信息，一般而言，系统在不断增长过程中往往需要引入某些独一无二的东西，这样导致了在面对大型复杂系统是C的扩展非常的难以管理；
2. 优点
   1. **强大的抽象封装能力**：这让C+语言具备了强大的开发工程能力，时在封装的同时C+最大程度的保留了高性能；
   2. **高性能**：运行快，快并且占用资源少一直是C+语言的追求
   3. **低功耗**：特别适合在各种微型的嵌入式设备中运行高效的程序
3. 缺点
   1. 语法相对复杂，细节比较多，**习曲线比较陡**；
   2. 需要一些好的**规范和范式**，否则代码很**难维护**

##  1-4 CPP的应用

- 大型桌面应用程序如 Google Chrome和 Microsoft office
- 大型网站的后台，如 Google的搜索引擎
- 游戏和游戏引擎（如 Unity）
- 视觉库和AI引擎（如 Opencv和 ITensorflow）
- 数据库（Microsoft SQL Server和 Mongodb）
- 其他（如自动驾驶系统，嵌入式设备等）
- 总结
  - 总得来说，C++的适合：开发成本比较高；对于内存和CPU要很高，低功耗并且程序被调用非常频繁等场景中，目前来说C++语言是最合适的语言。

1-5 第一章课后练习题



# 第2章 C++基础语法

本章讲解编程语言的层次，编译语言的特点；深入学习C++常见的标识符，关键字，数据类型，变量，常量及；IDE Visual Studio的安装，使用和调试方法；

##  2-1 编译型语言

- 编程语言的层次和类型

  1. 机器（Machine）语言，汇编语言等
  2. 编译型语言，如C++，C等；
  3. 解释型语言，如 Basic，Python等；
  4. 脚本语言，如bash，csh等；

- 从上到下使用层次更接近于人类使用但运行效率逐渐降低

- 编译型语言一般需要经历**犏译和链接**的过程，才能变成真正可执行的程序

  ![image-20210614151906425](重构你的C++知识体系.assets/image-20210614151906425.png)

##  2-2 语言的数据类型

- C++中的每个变量都有其数据类型，数据类型决定这变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。

![image-20210614163449148](重构你的C++知识体系.assets/image-20210614163449148.png)

```C++
// 常见数据类型的定义
char a[10]=a;
short int s= 97;
int m= 97;
long int n=97;
float f= 97.0f;
double d=97.0;
long double k=97.0;
bool b= true;
wchar_t w[10]=L"a";
```



##  2-3 开发环境的安装与使用1-安装

- 集成开发环境 Integrated Development Environment
  - 谈谈 Windows下的 `C++ IDE: Visual studio` 的安装与使用



2-4 开发环境的安装与使用2-使用于调试



##  2-5 语言的标识符和关键字

- C++中标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名字

  - 一个**标识符以字母 A-Z 或 a-z 或 下划线 开始**，后跟零个或多个字母、下划线和数字（0-9）；如 `button_emai1`
  - 一个标识符不允许使用数字开头，如 `1butn` 一个标识符内不允许出现标点字符，比如`@、&和%`
  - 不能将大小写混淆，C++是区分大小写的编程语言，比如，在C++ 中，Helloworld和 helloworld是两个不同的标识符
  - 不能使用C++关键字，原则上不允许长度超过32位

- 常见关键字（ keywords）

  | asm          | else      | new              | this     |
  | ------------ | --------- | ---------------- | -------- |
  | auto         | enum      | operator         | throw    |
  | bool         | explicit  | private          | true     |
  | break        | export    | protected        | try      |
  | case         | extern    | public           | typedef  |
  | catch        | false     | register         | typeid   |
  | char         | float     | reinterpret_cast | typename |
  | class        | for       | return           | union    |
  | const        | friend    | short            | unsigned |
  | const_cast   | goto      | signed           | using    |
  | continue     | if        | sizeof           | virtual  |
  | default      | inline    | static           | void     |
  | delete       | int       | static_cast      | volatile |
  | do           | long      | struct           | wchar_t  |
  | double       | mutable   | switch           | while    |
  | dynamic_cast | namespace | template         |          |

- 命名建议

  - 不要试图发明最好的命名规则，应该制定一个让大部分成员满意的命名规则，并且在项目组中贵彻执行
  - 标识符应该直观，可以望文知意，尽量使用英文单词组合的方式，不要使用汉语拼音；标
  - 识符的长度应当符合 `min-length&&max-information`原则，不是长度越长就越好，如 `maxVal` 比 `max Value UnitOverflow` 好；
  - 变量的名字尽量使用“名词”或“形容词+名词”，如vaue或newvalue，尽量**避免名字中出现数字**，如 value1，vaue2等，函数名可以使用“动词+名词”，如 DrawGraph

- 命名方式

  - Camel：驼峰
  - 匈牙利：类型+驼峰

##  2-6 变量与常量

- 变量定义的基本形式是：首先是型说明符随后紧跟由个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。如：`int m=1，n=1；`

- 常量：

  - 在程序运行过程中，其值一直保持不变的量为常量常量也区分不同的类型如：

    - 2，1024为整数型
      20f，1024.0为实数型
    - `‘h’`为字符类型，
    - “hello world”为字符串类型，
    - true，false为boo类型等
    - 在编辑器中根据其表面形式即可判断其类型

  - C++中有两种简单的定义常量的方法：

    1. 使用#define，如：`#define p3.1415926；`

    2. 使用 const；如：`const double pl=3.1415926；`注明：尽量使用 const定义变量，

       > #define不会出现在编译器期
       > #define Aspect_ratio 1.653; // 在编译时出错，很难排错
       > const double Aspect_ratio=1.653；//在编译时出错，可以排错

  - 整数常量可以是十进制、八进制或十六进制的常量。

  - 前缀指定基数：0x或0X表示十六进制，0表示八进制，不带前缀默认表示十进制。

  - 整数常量也可以带一个后缀，后缀是∪和L的组合，U表示无符号整数（unsigned），L表示长整数（long）。后缀可以是大写，也可以是小写，∪和L的顺序任意。

    ```c++
    //整数常量
    212 //合法的
    215u //合法的
    0xfeel //合法的
    078 //非法的：8不是八进制的数字
    032UU //非法的：不能重复后缀
    ```

- 字符常量是括在单引号中。

  - 单引号表字符，双引号表字符串；
  - 如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如L’x’），此时它必须存储在wchar_t类型的变量中。
  - 否则，它就是一个窄字符常量（例如x），此时它可以存储在char类型的简单变量中；
  - 字符常量可以是一个普通的字符（例如’x’）、一个转义序列（例如’\t’），或一个通用的字符（例如‘’\u02C0’)

2-7 语言的注释

```C++
/*123*/
//12342
```



2-8 第二章课后练习题

# 第3章 C++的运算符与表达式

理论结合实际，深入讲解C++表达式，表达式；分别讲解了算术运算符，关系运算符，逻辑运算符，位运算符，赋值运算符及杂项运算符及表达式，同时讲解了注释的用处和规范；

##  3-1 运算符表达式和基本语句

- 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号C++内置了丰富的运算符。
- 在程序中，运算符是用来操作数据的，因此，这些数据也被称为操作数，使**用运算符将操作数连接而成的式子**称为：表达式表达式具有如下特点：
  - 常量和变量都是表达式，例如，常量3.14、变量i；
  - 运算符的类型对应表达式的类型，例如，算术运算符对应算术表达式
  - 每一个表达式都有自己的**值**，即表达式都有运算结果；

3-2 算术运算符



3-3 关系运算符



##  3-4 逻辑运算符

- 断言运算符，判断值是否符合预期：`assert(1 != 1);`

3-5 赋值运算符



3-6 位运算符



##  3-7 杂项运算符及运算符的优先级

- sizeof si2eof运算符返回变量的大小。
- Condition？X:：Y条件运篁符。如果 Condition为真？则值为X：否则值为Y。
- （点）和->（箭头）成员运篁符用于引用类、结构和共用体的成员
- Cast强制转换运篁符把一种欻据类型转换为另一种数据类型。例如，int(2.200)将返回2。
- &指针运符&返回变量的地址。
- 指针运篁符 `*` 指向一个变量。

## 3-8 语言的注释。

- 好的命名和代码本身就是最好的注释；如果代码本身很清楚，不需要额外加注释
- 在重要代码段，或复杂代码处先写注释再写代码，这样思路更清晰，同时可以保证代码和注释的一致性；
- 注释不是越多越好，它是对代码的提示，如果要写就要清楚，并且保证和代码一致，如果更新了代码，请更新相应的注释

3-9 第三章课后练习

## 3-10 补码

![image-20210614210809551](重构你的C++知识体系.assets/image-20210614210809551.png)

![image-20210614210835469](重构你的C++知识体系.assets/image-20210614210835469.png)

![image-20210614210912489](重构你的C++知识体系.assets/image-20210614210912489.png)

![image-20210614210955598](重构你的C++知识体系.assets/image-20210614210955598.png)

![image-20210614211125429](重构你的C++知识体系.assets/image-20210614211125429.png)

- 为什么要用补码

  - 我们在设计软件系统时总是希望软件系统尽可能得简单通用于是人们希望

  - 在只有加法运算器的情况下设计一种方法能计算减法现在是8点，3小时前是5点，9小时以后呢，还是5点。

  - 为什么？

  - 因为：8+9-12=5，还是5点这里实际上进行了模12操作，还有一个关键点，总共只有12个数；我们得到一个结论

    8-3和8+9的结果是一样的；

     用9去表示-3然后如果想计算减法8-3，就直接在计算器上输8+9

![image-20210614212540778](重构你的C++知识体系.assets/image-20210614212540778.png)



3-11 补码2

3-12 补码及位运算说明

# 第4章 C++基础容器

本章我们将深入剖析C++数组：传统的数组优缺点及STL中vector的使用和思想；剖析C++的字符串： 对比C的字符串，C++的字符串，Redis字符串的处理；

##  4-1 序列容器--数组

- 概念
  代表内存里组连续的同类型存储区可以用来把多个存储区合并成一个擊体1-234比如
  `int arr[10]={1,2,3,4,5,6,7,8}`
- 数组声明
  `int arr[10]`
  - 类型名称n表示数组里所有元素的类型
  - 名称arr是数组的名称
  - 整数10表示数组里包含的元素个数
  - 数组里元素个数不可以改变
- 使用
  - 每个元素都有下标通过下标可以直接访问任意一个元素
  - 下标从0开始到元素个数减一为
  - 超过范围的下标不可以使用
  - 数组名称和下标一起可以表示数组里的元素 a[4]
- 优点
  - 可以编写循环依次处理数组里的所有元系
  - 循环变量依次代表所有有效下标

##  4-2 off-by-one error数组下标

![image-20210614214610073](重构你的C++知识体系.assets/image-20210614214610073.png)

- 这里最容易出错就是`high-low+1;`

![image-20210614214734879](重构你的C++知识体系.assets/image-20210614214734879.png)



![image-20210614215222003](重构你的C++知识体系.assets/image-20210614215222003.png)





##  4-3 数组增删改查及二维数组

- 访问数组

  - 时间复杂度 O(1)
  - 下标：`a[1]=5;`
  - 指针：`int *p=a; *(p+2)=5;`

- **查找数组**

  - 时间复杂度 O(n)

  ```c++
    int a[] = {1, 2, 3, 4};
    int len = sizeof(a) / sizeof(a[0]); //得到数组容量
    for (int index = 0; index < len; ++index)
    {
      if (a[index] == 3)
      {
        cout << index << endl;
        return index;
      }
    }
  ```

- **删除数组元素**

  ```C++
  
  ```

- **修改数组元素**

  ```C++
  
  ```

- **二维数组：**

  - 包含行列两个维度的数组

  ```C++
    int a[2][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}};
    for (int row = 0; row < 2; row++)
    {
      for (int col = 0; col < 4; col++)
      {
        cout << a[row][col] << " ";
      }
      cout << endl;
    }
  ```

  - tips：循环时尽可能要满足 “**空间局部性**”：
    - 在一个小的时间窗口内，**访问的变量地址越接近越好**，这样执行速度快；
    - 也就是说：一般来说，需要将**最长的循环放在最内层**，**最短的循环放在最外层**，以减少CPU跨切循环层的次数；

##  4-4 动态数组 Vector

4-5 动态数组vector2

- Vector **面向对象方式的动态数组**

  - 使用最简单的数组，无法实现动态扩容插入元素，因为容量有限

- **Vector 尾部添加操作**

  - 使用 Vector容器，轻松实现动态扩容插入元素，传统的C数组，容量有限，vector可以动态管理扩容；
  - `vec.push_back(5)`

  ```C++
  #include <vector>
    using namespace std; // 使用 vector之前的准备活动
    vector<int> vec = {1, 2, 3, 4};
    vec.push_back(5); // 在尾部进行元素插入操作
  ```

- **Vector 的遍历操作**

  - 可以使用 vec 的 `capacity` 和 `size` 方法来查看 vector当前的容量和已经存储的元素个数；

  ```C++
  #include <vector>
    using namespace std; // 使用 vector之前的准备活动
    vector<int> vec = {1, 2, 3, 4};
    cout << vec.capacity() << " " << vec.size() << endl; // 先查看大小，自动扩容
    vec.push_back(5);                                    // 在尾部进行元素插入操作
    for (int i = 0; i < vec.size(); i++)
    {
      cout << vec[i] << " " << vec.capacity() << " " << vec.size() << endl;
    }
  ```

- **Vector 的插入操作**

  - `vec.insert(--vec.end(),4);` 插入到最后一个元素之前

- **Vector 的删除操作**

  - `vec.pop_back();`  尾部删除
  - `vec.erase(vec.end()-1);` 删除尾部元素

```C++
  vector<int> vec = {1, 2, 3, 4};
  // 先查看大小，自动扩容
  for (int i = 0; i < vec.size(); i++)
  {
    cout << vec[i] << " " << vec.capacity() << " " << vec.size() << endl;
  }
  cout << "尾部插入" << endl;
  vec.push_back(5); // 尾部插入
  for (int i = 0; i < vec.size(); i++)
  {
    cout << vec[i] << " " << vec.capacity() << " " << vec.size() << endl;
  }
  cout << "尾部删除" << endl;
  vec.pop_back(); // 从尾部删除
  for (int i = 0; i < vec.size(); i++)
  {
    cout << vec[i] << " " << vec.capacity() << " " << vec.size() << endl;
  }
  cout << "指定位置插入" << endl;
  vec.insert(vec.end() - 1, 6); // 指定位置插入
  for (int i = 0; i < vec.size(); i++)
  {
    cout << vec[i] << " " << vec.capacity() << " " << vec.size() << endl;
  }
  cout << "指定位置删除" << endl;
  vec.erase(vec.end() - 2); // 指定位置删除
  for (int i = 0; i < vec.size(); i++)
  {
    cout << vec[i] << " " << vec.capacity() << " " << vec.size() << endl;
  }
```



##  4-6 字符串简介

- 字符串变量与常量

  - 字符串变量
    - 字符串是以空字符（`\0`）结束的字符数组
    - 空字符`'\0'`自动添加到字符串的内部表示中
    - 在声明字符串变量时，应该位这个空结束符预留一个额外元素的空间如：`char strHelloWorld1[11={"helloworld"}；`
  - 字符串常量
    - 字符串常量是一对双引号括起来的字符序列
    - 字符串中每个字符作为一个数组元素存储
    - 例如字符串"helloworld"

- 关于字符表示的说明

  - `0`，`'\0'`与 `‘0’`在计算机內部的机器码表示

    ```C++
    char c1=0   ;//0x00
    char c2='\0';//0x00
    char c3='0' ;//0x30
    ```

  - ASC码表

    - ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的-套电脑编码系统，主要用于显示现代英语和其他西欧语言。
    - 它是最通用的信息交换标准，并等同于国际标准SO/EC646ASC码使用指定的7位或8位二进制数组合来表示128或256种可能的字符。
    - 编码表可以参考：
      0×41（十进制65）对应A；0x30（十进制48）对应字符“00×61（十进制97）对应a；0X7F（+进制127）对应字符DEL

  - Unicode编码最初的目的是把世界上的文字都映射到一套字符空间中；

    - 为了表示 Unicode字符集，有3种（确切的说是5种）Unicode的编码方式
      1. UTF8：1byte来表示字符，可以兼容ASC码特点是存储效率高，变长（不方便内部随机访问）无字节序问题（可作为外部编码）
      2. UTF-16：分为UTF16BE（big endian）
         UTF-16LE（little endian特点是定长（方便内部随机访问
         有字节序问题（不可作为外部编码）
      3. UTF-32：分为UTF-32 BE（big endian UTF-32LE（little endian特点是定长（方便内部随机访问，有字节序问题（不可作为外部编码）
    - 编码错误的根本原因在于编码方式和解码方式的不统一；
    - Windows的文件可能BOM（byte order mark）如要在其他平台使用，可以去掉BOM

4-7 Unicode编码



##  4-8 字符串的指针表示

1. 指针表示方法：`char*pstrhello Wrold helloworld` 
2. `char[]`和`char*`的区别，把握两点：
   - 地址和地址存储的信息；可变与不可变；
3. **值可变不可变取决于所指区间的存储区域是否可变**；
   - 取决于内存区间，只能修改变量区间的值。

##  4-9 字符串基本操作

4-10 字符串基本操作2

- 字符串基本操作，兼容C语言

  - 字符串长度：`strlen(s)`
    返回字符串的长度，实际长度
  - 字符串比较：`strcmp(1，S2)`
    如果s1和s2是相同的，则返回0；如果s1<s2则返回值小于0如果s1>s2则返回值大于0
  - 两个字符串自左向右逐个字符相比（按ASC值大小相比较），直到出现不同的字符或遇`'\0'`为止。如：`"A"<"B“"A"<"AB"；"Apple"<"Banana A"<"a"compare"<"computer"`
  - 字符串拷贝：`strcpy(s1，s2)`
    复制字符串s2到字符串s1；
  - 复制指定长度字符串：`strncpy（s1,s2,n)`，将字符串s2中前n个字符拷贝到s1中
  - 字符串拼接：`strcat（s1，s2）`
    将字符串s2接到s1后面
  - 查找字符串：`strchr（s1，ch）`
    指向字符串s1中字符ch的第一次出现的位置；
  - 查找字符串：`strstr（s1，s2）`
    指向字符串s1中字符串s2的第一次出现的位置；

- 去掉 API 警告：`_CRT_SECURE_NO_WARNINGS`

  ![image-20210615030116586](重构你的C++知识体系.assets/image-20210615030116586.png)

  - 会导致内存溢出问题，可以修改变量或语句
  - 新的安全 API
    - `strcpy_s()`
    - `strcat_s()`: `strcat_s(strHelloWorld2, STR LEN NUM, " Welcome to C++);`
  - 注请使用 `strlen_s，strcpy_s，strncpy_s，strcat_s`等AP函数，更安全

- Redis 字符串的设计https://redis.io

  ![image-20210615032854986](重构你的C++知识体系.assets/image-20210615032854986.png)

##  4-11 string的简介

- C++标准库中提供了 string类型专门表示字符串：

  ```C++
  #include <string>
  using namespace std;
  ```

- 使用 string可以更为**方便和安全**的管理字符串

- 定义字符串变量

  ```C++
  string s;//定义空字符串
  string s="helloworld";//G定义并初始化
  string s=("helloworld");
  string s= string("helloworld");
  ```

- 获取字符串的长度

  ```C++
  cout << s1.length() << endl;
  cout << s1.size() <<end;//本质和上面一样
  cout << s1 capacity()<< end;
  ```

- 字符串比较：`== != > >= < <=`

- 转换为C风格的字符串

  ```C++
  const char*c_str1 =s1.c_(); 
  cout <<The C-style string c_str1 is："<<c_str1<< endl;
  ```

- 随机访问（获取字符串中某个字符）：`[]`
  `string s="hello"; s[0]="h";//hello`

- 字符串拷贝：`=`
  `string s1="hello"`
  `string s2=s1`

- 字符串连接：`+、+=`

  ```C++
  string s1 ="hello", S2 =world;
  string s3=S1 +s2;//s3：helloworld 
  s1+=s2;//s1：helloworld
  ```

- 总结：string结合了C++的新特性，使用起来比原始的C风格方法更安全和方便，对性能要求不是特别高的常见可以使用。



# 第5章 彻底学会 C++ 指针，引用

指针是C++重点：深入讲解指针的概念，各种类型的指针，const指针，数组指针与指针数组；指针的指针，指向函数的指针；更高级的内容：如何避免野指针，各种指针的使用场景，及实际工程中必须避免的用法和相对好的做法；讲解引用与指针的关系： 会使用引用，知道实际工程中比较好的一些做法；...

## 5-1 指针的概念



## 5-2 左值与右值



## 5-3 一般指针，数组指针和指针数组



## 5-4 const与指针





## 5-5 指向指针的指针



## 5-6 关于野指针



## 5-7 指针的基本操作一



## 5-8 指针的基本操作二



## 5-9 指针的基本操作三



## 5-10 CPP程序的存储区域划分



## 5-11 CPP程序的存储区域划分总结



## 5-12 CPP动态分配和回收原则



## 5-13 RAII初步



## 5-14 几种变量的对比



## 5-15 内存泄漏



## 5-16 智能指针auto_ptr



## 5-17 智能指针unique_ptr



## 5-18 shared_ptr和weak_ptr理论讲解



## 5-19 shared_ptr和weak_ptr代码演示



## 5-20 引用



# 第6章 C++基础句法

深入讲解基本语句：赋值语句，判断语言，循环语言for, while；深入讲解基本数据与结构，枚举，结构体和联合体；深入讲解函数，递归函数的来龙去脉；浅析类与面向对象的概念；谈谈命名空间的使用。

## 6-1 图灵机与三种基本结构



## 6-2 if语句基础



## 6-3 if语句的例子



## 6-4 switch分支基础



## 6-5 switch和if的对比



## 6-6 自定义类型--枚举



## 6-7 自定义类型--结构体与联合体



## 6-8 结构体的内存布局



## 6-9 三种循环的基本使用与比较



## 6-10 for循环的一个优化实例



## 6-11 函数基础



## 6-12 函数重载overload与Name Mangling



## 6-13 指向函数的指针与返回指针的函数



## 6-14 命名空间。



## 6-15 函数体的Hack过程



## 6-16 内联函数。



## 6-17 数学归纳法与递归



## 6-18 递归的特点和Hack过程



## 6-19 尾递归的优化



## 6-20 递归的动态规划思路



# 第7章 C++高级语法

深入剖析C++类型转换：显式转换的四种常见的方式，隐式转换类型转换的影响； 用通俗易懂的方式深入浅出讲解异常，IO，文件，线程，模版编程，这些很难难用的部分；

## 7-1 从抽象到面向对象编程



## 7-2 面向对象的抽象法则1-具体类型的抽象



## 7-3 对象的属性



## 7-4 运算符重载



## 7-5 拷贝构造及临时对象的优化



## 7-6 前置与后置操作符



## 7-7 标准输入输出IO重载



## 7-8 IO流基础



## 7-9 IO缓存区



## 7-10 文件操作基础



## 7-11 文本文件的操作



## 7-12 二进制文件的操作



## 7-13 Complex其他运算符重载



## 7-14 头文件重复包含问题



## 7-15 关于前七章的练习题及答案



## 7-16 深拷贝浅拷贝及move语义的优化



## 7-17 面向对象的抽象法则2



## 7-18 Hack对象模型和虚函数



## 7-19 面向对象三大特性及总结



# 第8章 C++编程思想

深入再谈Class；深入再谈面向对象模式，23种设计模式的思路和最常用的单例，观察者模式等在工程中的实际使用；分析C++模版编程范式；

## 8-1 软件的设计模式



## 8-2 单例模式



## 8-3 static和单例模式的实现



## 8-4 观察者模式



## 8-5 list的使用和观察者模式的实现1



## 8-6 观察者模式的实现2



## 8-7 void星NULL和nullptr



## 8-8 static_cast的使用



## 8-9 reinterpret_cast的使用



## 8-10 static_cast和dynamic_cast的使用



## 8-11 Adapter模式和多重继承



## 8-12 Adapter组合方式实现



## 8-13 设计模式总结



## 8-14 泛型编程之泛型函数1



## 8-15 泛型编程之泛型函数2



## 8-16 泛型编程的递推过程及总结



# 第9章 C++进阶编程

深入讲解STL思想，细致讲解容器，算法，C++内存分配，迭代器等STL编程方法，String类等，讲解Boost库的使用技巧；

## 9-1 STL标准库简介



## 9-2 序列型容器和函数对象基本使用



## 9-3 关联容器map的基本使用和查找



## 9-4 关联容器的插入删除及迭代器失效问题



## 9-5 从函数指针到仿函数模板



## 9-6 算法transform和lambda表达式



## 9-7 STL容器的统计与二分查找



## 9-8 从手写全排列到STL的实现



## 9-9 迭代器基本使用



## 9-10 手写GC与异常



## 9-11 自定义迭代器与手写GC



## 9-12 容器适配器



## 9-13 空间配置器初步



## 9-14 自定义空间配置器



## 9-15 STL空间配置器源码剖析与STL总结



## 9-16 关于Boost库



## 9-17 CPP多线程基础



## 9-18 多线程银行存取款案例



## 9-19 多线程小结



# 第10章 桌面应用项目实战：设计项目的架构和标准

项目的实现效果介绍及项目使用的技术框架；

## 10-1 慕影项目的效果展示



## 10-2 项目环境的安装和部署



## 10-3 项目的基本架构和pro文件



## 10-4 项目中用到的大致QT知识



# 第11章 实现项目《慕影》的通用组件模块：

介绍QT项目的基本类库，字符串类，智能指针类及调试信息等；

## 11-1 QT和VS的项目使用



## 11-2 QT项目的基础架构类和UI类



## 11-3 QQString的基本使用



## 11-4 QDebug的基本使用



## 11-5 QT的智能指针QScopedPointer



## 11-6 QThread的使用



# 第12章 《慕影》播放器UI模块开发

实现项目UI部分，qml与C++的交互方式，换肤模块的开发；

## 12-1 项目的整体UI架构



## 12-2 项目资源和UI加载的流程



## 12-3 qml的最基本使用和项目绑定



## 12-4 修正一个bug和框架调整



## 12-5 qml属性的基本使用



## 12-6 项目的换肤实现1



## 12-7 项目的换肤实现2



## 12-8 项目的换肤实现3



## 12-9 项目的换肤实现4



# 第13章 实现《慕影》音视频模块开发

实现项目PCM, 核心音频模块功能，核心视频模块功能，了解开源架构ffmpeg的设计和使用；

## 13-1 音视频采样编码的基本原理



## 13-2 ffmpeg的基本情况



## 13-3 PCM过程的一些基本参数



## 13-4 读取PCM音频文件进行播放1



## 13-5 读取PCM音频文件进行播放2



## 13-6 视频的封装格式及播放的基本流程



## 13-7 ffmpeg的解码大致流程



## 13-8 ffmpeg程序的环境配置



## 13-9 ffmpeg编写解码程序1



## 13-10 ffmpeg编写解码程序2



## 13-11 ffmpeg编写解码程序3



## 13-12 ffmpeg编写解码程序4



# 第14章 《慕影》播放器项目总结

项目整体的代码讲解，分析与总结

## 14-1 项目总结



## 14-2 项目UI功能总结



## 14-3 项目播放功能总结1



## 14-4 项目播放功能总结2



# 第15章 C++的陷阱和经验

通过剖析C++常见经典著作和对一些大牛的经验解读，排除大家学习C++的坑，为大家将来成为C++技术大牛铺设一条基本路线；

## 15-1 谈谈个人的学习工作经历
## 15-2 谈谈个人学习工作的一点感悟
## 15-3 推荐几本CPP的书籍
## 15-4 谈谈CPP的陷阱

# 第16章 课程总结

总结C++基础知识在项目中的应用，项目中可能的坑和存在改善的问题；

 16-1 课程总结